<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="engine.css">
</head>

<body>
  <main>
    <div class="container">
      <div class="nav-items">
        <div><a href="https://github.com/lazear"><img src="github-brands.svg" style="width: 24px"></a></div>
        <div><a href="https://twitter.com/michaellazear?lang=en"><img src="twitter-brands.svg" style="width: 24px"></a>
        </div>
        <div><a href="https://www.linkedin.com/in/michael-lazear-27781282/"><img src="linkedin-brands.svg"
              style="width: 24px"></a></div>
        <div><a href="https://orcid.org/0000-0001-5313-4262"><img src="orcid-brands.svg" style="width: 24px"></a></div>
      </div>
      <!-- <div class="row"> -->
      <article class="article">
        <section class="section">
          <h1>Proteomics searching so fast it seems like Magic</h1>
          <em>Introducing Sage: a new cross-platform, extremely performant, open source proteomics search engine;
            written in
            Rust</em>

          <!-- <p>I wanted to see what how far I could get in the creation of a proteomics search engine in a weekend (or
            two), and
            ~1500 lines of code, and this is the result!</p> -->
          <p>Here are some of the features of Sage:</p>
          <ul>
            <li><i>Super-ultrafast</i><sup class="footnote-ref"></sup> out of the box,
              <aside class="footnote">What? MSFragger already took <i>ultrafast</i></aside>
            </li>
            <li>Cross platform: natively run on Windows, MacOS, or Linux</li>
            <li>Small and simple <a href="https://github.com/lazear/sage">codebase</a>, including comments & tests</li>
            <li>Fragment indexing strategy <i>a la</i> MSFragger allows for blazing fast narrow & open searches</li>
            <li>Can assign multiple peptides to a single spectrum <a href="#chimera">(chimeric/co-fragmenting
                spectra)</a></li>
            <li>FDR calculation using target-decoy competition, with built-in and incredibly fast <a href="#lda">linear
                discriminant analysis</a></li>
            <li>PEP calculation using a built-in non-parametric kernel density estimator</li>
            <li>Percolator/Mokapot compatible output (provides minimal improvement over built-in LDA model)</li>
            <li>MS3-TMT quantification, with calculation of SPS precursor ion purity, for <a href="#tmt">reduced TMT
                interference</a></li>
            <li>Configuration by JSON files</li>
            <li><a href="https://opensource.org/osd">Open Source</a> & Free Software<sup class="footnote-ref"></sup>
              <aside class="footnote">
                MSFragger is not <a href="https://www.fsf.org/">Free Software</a> despite what others may claim<sup><a
                    href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6469856/">1</a></sup> - it's not even open
                source! There are also a significant number of closed source proteomics tools in general - I believe
                that scientists deserve to have complete control over the tools they use, especially in a field as
                dependent on software as proteomics.
              </aside>
            </li>
            <li>Sage is organized as both a binary and an extensible Rust library, enabling integration into other
              applications</li>
          </ul>

          <p>And some features that are work-in-progress:</p>
          <ul>
            <li>Peptide & protein FDR calculation using picked- approaches</li>
          </ul>

          <p>Finally, some disclaimers and forewords:</p>
          <ul>
            <li><i>Caveat emptor</i> - Sage has great performance, but it is still missing some features found in
              many other search engines. Use it at your own risk (if you do decide to try it out, please don't hesitate
              to contact me!)</li>
            <li>I made best efforts to benchmark Comet and MSFragger in good faith, including reaching out to their
              maintainers to check parameters
              <sup class="footnote-ref"></sup>
              <aside class="footnote">
                <a href="http://comet-ms.sourceforge.net/parameters/parameters_202101/">Comet parameters</a>
                <br>
                <a href="https://github.com/Nesvilab/MSFragger/wiki/Setting-the-Parameters">MSFragger parameters</a>
              </aside>

              - that being said, it is totally possible that I have misconfigured them.
              You can find the benchmarking parameters (along with all of the code!) in the <a
                href="https://github.com/lazear/sage/tree/master/figures/benchmark_params">Sage GitHub
                repository</a>. They are both great, widely-used, full-featured tools and I recommend incorporating them
              into your workflows! Sage stands on the shoulders of giants.
            </li>
            <li>This was undertaken largely for fun and self-learning purposes - as such, this isn't a
              peer-reviewed project (yet). However, hopefully it can serve as a
              pedagogical tool, as I have tried to keep the codebase small (~1500 loc), well commented, tested, and
              amenable to hacking on.
            </li>
            <li>Sage only accepts mzML files as input</li>
          </ul>

          Now that the boilerplate is out of the way, you can head <a href="#standoff">below</a> if you want to skip
          right to the showdown at high noon, otherwise,
          you can read through the full post to see a graphical depiction of the algorithm used here (spoiler: it's a
          clean-room implementation of the MSFragger algorithm, but open-source).
        </section>
        <section class="section">
          <h2><a id="intro"></a>Proteomics database searching</h2>
          <div>
            I had recently been playing around with the idea of writing my own proteomics search engine<sup
              class="footnote-ref"></sup>
            , so I started
            digging into the literature.
            <aside class="footnote"> Given that my PhD revolved around proteomics, and I currently work as a software
              engineer/informatics
              scientist at a <a href="https://www.belharratx.com/">proteomics-based drug discovery company</a>, I
              figured
              this is
              something I should understand well enough to implement from scratch. I also just really enjoying building
              things.
            </aside>

            One weekend (and some change) of flow-state coding later, and I accidentally created something
            that blows it's competitors to smithereens in the speed and memory-efficiency department. Oh, and it will
            run on
            Windows, MacOS, and Linux as a native binary, as well as take advantage of Rust's fantastic "fearless
            concurrency" to utilize as close to 100% of available CPUs as possible.
          </div>



          Since the introduction of SEQUEST<sup><a href="https://pubmed.ncbi.nlm.nih.gov/24226387/">2</a></sup> in
          1994, proteomics has generally relied on the concept of database searching for peptide identification<sup><a
              href="https://pubmed.ncbi.nlm.nih.gov/18505281/">3,</a></sup><sup><a
              href="https://pubmed.ncbi.nlm.nih.gov/25358478/">4,</a></sup><sup><a
              href="https://pubmed.ncbi.nlm.nih.gov/23148064/">5,</a></sup><sup><a
              href="https://pubmed.ncbi.nlm.nih.gov/19029910/">6</a></sup>
          where a spectrum is compared against all theoretical
          peptide candidates within a precursor tolerance window and scored for spectral similarity.<sup
            class="footnote-ref"></sup>
          <aside class="footnote">
            This approach has had great success, but it is exhaustive, and thus slow. Every candidate peptide within
            the precursor tolerance window is compared against the experimental spectrum, even if there are no shared
            fragment peaks
          </aside> There are also additional approaches like <i>de novo</i> peptide sequencing, spectral library
          matching, and using machine
          learning models for embedding spectra, but those are outside the scope of this work.

          <p>
            <img src="Figure 1.png" class="large" />
          <figcaption>Cartoon schematic of a typical proteomics workflow</figcaption>
          </p>
          <p>Andy Kong and Alexey Nesvizhskii from
            University of Michigan presented an alternate approach in their <a
              href="https://pubmed.ncbi.nlm.nih.gov/28394336/">2017
              paper</a> detailing their new database search tool:
            MSFragger. Rather than exhaustively search through all candidate peptides based on precursor mass,
            they instead combine all theoretical fragments from every peptide in the database - and then search
            by fragment m/z and filter by precursor mass: "In the MSFragger strategy, theoretical spectra that
            share no common fragments are effectively bypassed". They spend a couple paragraphs in the methods
            section outlining the algorithm and search steps, but the codebase itself is closed source
            and
            binaries are only freely available for non-commercial use (which Alexey kindly reminded me of when I emailed
            him about benchmarking MSFragger). Regardless, it's an elegant and performant
            reformulation of database searching, and it captured my imagination enough that I had to try my hand at
            implementing it.</p>

        </section>
        <section class="section">
          <h2><a id="data-structure"></a>Fragment Index data structure</h2>
          <blockquote>
            <p>"Show me your code and conceal your
              data structures, and I shall continue to be mystified. Show me your data structures, and I won't
              usually need your code; it'll be obvious."</p>
            - <a href="https://lwn.net/Articles/193244/">Altered quote</a> by Fred Brooks
          </blockquote>
          <div>Despite (perhaps, because of) the code
            for this important piece of scientific software being <strong>closed source</strong>, I spent a weekend
            creating my
            own implementation of the "fragment index" algorithm - it's a multi-level B-tree laid out as an
            in-memory array, supporting range queries. We will walk through both the construction of the data
            structure, as well as the algorithm for running a search.<sup class="footnote-ref"></sup>
            <aside class="footnote">There are some low-level performance tricks that we won't discuss in detail, since
              they aren't relevant to data structure itself</aside>
          </div>
          <div style="margin-top: 1rem;">For the sake of concise examples, we will
            be using the sequence of <a href="https://www.uniprot.org/uniprotkb/Q99536/entry">Human VAT1</a> as
            our FASTA database.<sup class="footnote-ref"></sup>
            <aside class="footnote">
              Normally, we would use the entire human proteome.
              To further simplify matters, we will also only cover charge state = 1, and we will ignore missed
              cleavages.
            </aside>
          </div>
          <img src="Figure 2.png" />
          <figcaption>FASTA database is digested into theoretical tryptic peptides (minimum length of 5 amino acids).
            b-/y-ions are then generated
            for each peptide</figcaption>
          <p>
          <h3>Data structure construction:</h3>
          <ol>
            <li>After <em>in silico</em> digestion
              of our database (using trypsin with 0 missed cleavages, in this case), we de-duplicate our list
              of peptides and then sort them by mass.</li>
            <li>Next, we generate all theoretical
              b- and y- fragment ions for each peptide in our list, collecting them in an array.</li>
            <li>After every fragment ion has been
              generated for all peptides in the database, we sort the entire list by <strong>fragment
                mass</strong>.</li>
            <li>The following step is key: we
              create discrete bins of fragments (16 fragments/bin in this example, or 1 row), and within each
              bin we now sort by <strong>precursor mass</strong>.</li>
          </ol>
          </p>
          <img src="Figure 3.png" class="large" />
          <figcaption>Graphical representation of the algorithm for constructing the fragment tree data
            structure.
            Peptides are colored by increasing
            mass, with an example peptide - LQSRPAAPPAPGPGQLTLR - in blue to enable easier dissection of the steps. Each
            ball represents a single fragment ion (either b or y), colored by precursor mass.
          </figcaption>
          <p>We now have our 2 level binary tree:
            the outer level acts as a B+ tree, allowing us to rapidly select bins containing fragments within a given
            window, and
            within each bin we can run a binary search for fragments whose precursor is within our desired tolerance.
          </p>

          <p>Here is the simplified search algorithm in pseudocode:</p>
          <div class="codeblock">
            <code>
              function scoreSpectrum(precursorMz, spectrum):<br>
              &nbsp;&nbsp;scores <- {}<br>
              &nbsp;&nbsp;for fragmentMz, fragmentInt in spectrum:<br>
              &nbsp;&nbsp;&nbsp;&nbsp;innerBTree <- binarySearch(outerBTree, fragmentMz +/- tolerance)<br>
               &nbsp;&nbsp;&nbsp;&nbsp;theoretical <- binarySearch(innerBTree, precursorMz +/- tolerance)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;for candidate in theoretical:<br>
                 &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;scores[candidate] += fragmentInt<br>
<br>
                sort(scores)<br>
                best <- scores[0]<br>
            </code>
          </div>

          <img src="Figure 4.png" />
          <figcaption>Optimally assigning peptide-spectrum matches just involves a series of binary searches,
            followed by a scoring function</figcaption>
          <h3>The real deal</h3>
          <p>Finally, here is what our example
            peptide-spectrum match looks like after annotated with matching peaks: there are ~4000 potential
            candidates based solely on precursor mass - our algorithm only ends up scoring ~1500 of them,
            because the remainder do not have any fragment peaks in common with our experimental spectrum! And
            for those ~1500, on average only 1-2 fragments are actually compared. This is in stark contrast to
            how SEQUEST or Comet would score the same spectrum: comparing all fragments for all 4000 peptides.
          </p>
          <img src="LQSRPAAPPAPGPGQLTLR.png" />
          <figcaption>Human VAT1 peptide annotated by Sage</figcaption>
        </section>
        <section class="section" id="standoff">
          <h2>Benchmarking Results</h2>

          My proteomics engine is based off of MSFragger's algorithm, so it would be reasonable to expect them to have
          similar
          performance - however, this is where Rust really shines! I will let the results speak for
          themselves, though!

          <div style="margin-top: 1rem">
            <ul>

              <li>All searches were run on c5ad.8xlarge EC2 spot instances (32 vCPU cores, 64 GB RAM, NVMe disks,
                $0.75/hr)
                using:
                <ul>
                  <li>the same
                    FASTA database,<sup class="footnote-ref"></sup>
                    <aside class="footnote">
                      Most recent reviewed Human FASTA file, with decoys concatenated. Database prepared using <a
                        href="https://github.com/Nesvilab/philosopher">Philosopher</a>
                    </aside>
                  </li>
                  <li>and the same input mzML files (processed using <a
                      href="https://proteowizard.sourceforge.io/download.html">MSConvert</a>).
                  </li>
                </ul>
              </li>
              <li>

                Post search FDR refinement was performed using Will Fondrie's excellent <a
                  href="https://github.com/wfondrie/mokapot">Mokapot</a> tool
              </li>

              <li>In general, I stuck to default search parameters/workflows for Comet & MSFragger, where possible -
                changing things only to match them across engines. You can find the benchmarking parameters (along with
                all of the code!) in the <a
                  href="https://github.com/lazear/sage/tree/master/figures/benchmark_params">Sage GitHub
                  repository</a>.
              </li>
              <li>All searches were performed without variable modifications, since each engine handles these somewhat differently</li>
              <li>Performance will vary across systems - Sage performs best on amd64 systems running *nix operating
                systems - but it will also run pretty well on aarch64 or Windows setups!</li>
              <li><a href="https://github.com/UWPR/Comet">Comet</a> & Sage were both compiled from source on the EC2
                instance, <a href="https://msfragger.nesvilab.org/">MSFragger</a> jar was used as
                downloaded, <a href="https://github.com/levitsky/identipy">IdentiPy</a> was installed via pip.</li>
              <li>I was going to benchmark MSGF+ as well, but it too slow (it took over 12 minutes
                for a
                <i>single</i> mzML file from the TMT dataset - about 750x slower than Sage)</strong>. Given that EC2
                instances aren't free,
                I will let the reader spend $1 to run a single replicate of this benchmark themselves :)
              </li>
            </ul>
          </div>

          <p>To benchmark TMT search performance, I downloaded high res TMT-MS2 data from the paper <a
              href="https://pubs.acs.org/doi/10.1021/acs.analchem.9b05685?goto=supporting-info">Benchmarking the
              Orbitrap
              Tribrid Eclipse for Next Generation Multiplexed Proteomics</a> from PRIDE <a
              href="http://proteomecentral.proteomexchange.org/cgi/GetDataset?ID=PXD016766">PXD016766</a>
          </p>


          <h4>If MSFragger is "ultrafast", what is Sage?</h4>

          <p>I half-joke: MSFragger really is fast! But, Sage is about 5x faster than MSFragger, 20 faster than
            Comet, 150x faster than IdentiPy, and 500x faster than MSGF+ on
            a typical TMT search
            and identifies a similar number of PSMs at 1% FDR.
          </p>
          <p>Sage is so fast that computational cost of searching becomes irrelevant - you could
            re-process all of PRIDE's annotated PSMs
            (580,917,172 at current count) using Sage for less than $3, assuming you had the bandwidth to keep the
            engine fed!
          </p>


          <img src="tmt_search.png" class="large" />
          <figcaption>Note that the times on the graph are log2 transformed!</figcaption>

          <table>
            <thead>
              <tr>
                <th>Engine</th>
                <th>Runtime*</th>
                <th>Cost to process 12 mzML files</th>
                <th>PSMs at 1% FDR</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Sage</td>
                <td>18 s</td>
                <td>$0.0038</td>
                <td>100,448</td>
              </tr>
              <tr>
                <td>MSFragger</td>
                <td>101 s</td>
                <td>$0.0210†</td>
                <td>97,844</td>
              </tr>
              <tr>
                <td>Comet</td>
                <td>345 s</td>
                <td>$0.0716</td>
                <td>92,333</td>
              </tr>
              <tr>
                <td>IdentiPy</td>
                <td>3128 s</td>
                <td>$0.6495</td>
                <td>96,465</td>
              </tr>
              <tr>
                <td>MSGF+</td>
                <td>>9000 s<sup>#</sup></td>
                <td>$1.8690</td>
                <td>-</td>
              </tr>
            </tbody>
          </table>
          <figcaption>
            * Including FDR refinement (mokapot for other engines, or Sage's built-in ML models)<br>
            † plus licensing fee, presumably<br>
            <sup>#</sup> benchmarking terminated after first file due to
            cost, time is extrapolated
          </figcaption>



          For a proteomics experiment, performance isn't everything... peptide-spectrum matches are! Sage also
          exhibits very good PSM
          identification rates and identity overlap when compared against both Comet and MSFragger<br>

          <img src="venn.png" width="80%" />
          <figcaption>PSM identity overlap from Mokapot results
          </figcaption>

          <h3>Open search</h3>

          <div>One of the big benefits of the fragment-indexing strategy is that efficient open searches can be
            performed. These kind of searches dramatically increase the precursor mass tolerance window - sometimes up
            to +/- 500 Da! This enables unbiased detection of post-translational or chemical modifications.
            The MSFragger paper shows several open search benchmarks, so I figured I would replicate it myself.
          </div>

          To benchmark open search performance, I used the same file MSFragger used in their paper: the first dataset
          (b1906_293T_proteinID_01A_QE3_122212.mzXML)
          from the paper <a href="https://www.ncbi.nlm.nih.gov/pubmed?term=26076430">An Ultra-tolerant Database Search
            Identifies more than 100,000 Modified Peptides</a> (<a
            href="http://proteomecentral.proteomexchange.org/cgi/GetDataset?ID=PXD001468">PXD001468</a>)

          <img src="open_search.png" class="large" />
          <figcaption>MSFragger takes the lead on PSM identification by a couple hundred IDs once we start hitting
            open-search</figcaption>

          <h3>Wide open</h3>
          Let's open up our precursor mass window to -100 Da to +500 Da; this is typical of a search for unknown PTMs or
          chemoproteomic applications.

          <img src="500_search.png" class="large" />
          <figcaption>MSFragger gains a ~5% lead as the precursor windows get wider</figcaption>

          <p>
            And, this is where MSFragger really shines - it identifies ~1,000 extra PSMs from this single file search
            when we
            really open up the precursor window. Room for improvement for Sage! (Read below to see one strategy of
            improving this - chimeric searching)
            You'll note that Comet isn't in this graph - I don't think there's any point in benchmarking it, timewise,
            and
            it also doesn't seem amenable to doing a non-symmetrical precursor window. Given that most modifications
            involve the <i>addition</i> of a PTM (and thus positive mass shift), it makes sense to use asymmetric
            windows
            for an open search strategy.
          </p>


          <strong>-100 to 500 Da precursor, ±10 ppm fragment window:</strong>
          <table>
            <thead>
              <tr>
                <th>Engine</th>
                <th>Runtime</th>
                <th>PSMs at 1% FDR</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Sage</td>
                <td>113 s</td>
                <td>24,432</td>
              </tr>
              <tr>
                <td><a href="#chimera">Sage Chimera</a></td>
                <td>171 s</td>
                <td><strong>28,049</strong></td>
              </tr>
              <tr>
                <td>MSFragger</td>
                <td>185 s</td>
                <td>25,534</td>
              </tr>
            </tbody>
          </table>

          <p>Don't think that you need a beefy c5ad.8xlarge instance to go fast - I can complete the same 600 Da open
            search on my <strong>MacBook M1 Air</strong> (8 cores, 16 GB RAM) in ~7.5 minutes!</p>

          <img src="delta_mass.png" class="large">
          <figcaption>Open chimeric search with Sage reveals common modifications. Y-axis trimmed, vast majority
            (>15,000) of PSMs are centered around 0</figcaption>

        </section>
        <!--  
        <section class="section">
          <h2>Benchmarking against synthetic peptide datasets</h2>

          With many proteomics searches, we often don't have a "ground truth" for which peptides are actually present in
          a sample - lucky for us, the <a href="https://www.nature.com/articles/nmeth.4153">ProteomeTools</a> project
          out of TUM has been
          building a
          complete synthetic human proteome. To test it out, I downloaded the ProteomeTools HCD Spectral Library (some
          260,000 spectra) from <a
            href="https://massive.ucsd.edu/ProteoSAFe/static/massive-kb-libraries.jsp">MassIVE</a> and used MSConvert
          to convert the MGF file to an mzML.
          <p>This dataset allows us to actually determine if our PSM identifications match up to what they "should" be -
            each spectrum is annotated with the sequence of it's synthetic peptide precursor.
            I started Sage, and 10 seconds later we correctly identified 215,281 PSMs with a 1% FDR - there were 1,055
            PSMs that were correctly ID'ed with q > 0.01 (for a total of 216,336 correct PSMs). I left Comet out of the
            last comparison, so we'll bring it back into the fold for this experiment:
          </p>

          <strong>±20 ppm precursor, ±10 ppm fragment window:</strong>
          <table>
            <thead>
              <tr>
                <th>Engine</th>
                <th>Runtime</th>
                <th>1% FDR</th>
                <th>All</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Sage</td>
                <td>10 s</td>
                <td>215,281</td>
                <td>216,336</td>
              </tr>
              <tr>
                <td>Comet</td>
                <td>130 s</td>
                <td>210,190</td>
                <td>210,688</td>
              </tr>
            </tbody>
          </table>

          <figcaption># of correctly identified PSMs from ProteomeTools HCD Synthetic Spectral Library - Sage correctly
            identifies an extra 5,000 PSMs</figcaption>

          <div>I wasn't satisfied with 260,000 spectra - luckily for me, MassIVE also hosts a 2.1 million spectra HCD
            library from <i>in vivo</i> proteomics experiments, which I
            downloaded next. Sage cranked through 2.1M spectra in 137 seconds - 62 seconds of which was spent just
            parsing the mzML file, and another 48 seconds on fitting a non-parametric model for PEP calculation<sup class="footnote-ref"></sup>
            <aside class="footnote">
              I promised myself I wouldn't get started on a rant about XML based file formats...
            </aside> - yes, that's 79k spectra/s on a c5ad.8xlarge instance (I've seen speeds >2,500
            specta/CPU-second)
          </div>
          <p>(NB: no variable mods (only cysteine carbidomethylation) and only 1 missed cleavage were used in search,
            which will reduce the # of possible correct matches to ~1.5M). Here are
            the number of correct PSM identifications:</p>

          <img src="Massive_2.png" class="large" />
          <figcaption>Left panel: Distribution of q-values for correctly identified PSMs. Middle panel: I would call
            this super-ultrafast</figcaption>

          <strong>±20 ppm precursor, ±10 ppm fragment window:</strong>
          <table>
            <thead>
              <tr>
                <th>Engine</th>
                <th>Runtime*</th>
                <th>1% FDR</th>
                <th>All</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Sage</td>
                <td>137 s</td>
                <td>782,049</td>
                <td>815,548</td>
              </tr>
              <tr>
                <td>MSFragger</td>
                <td>437 s</td>
                <td>777,186</td>
                <td>795,633</td>
              </tr>
              <tr>
                <td>Comet</td>
                <td>1744 s</td>
                <td>787,541</td>
                <td>815,261</td>
              </tr>
            </tbody>
          </table>
          <figcaption>
            * Including FDR refinement (mokapot for other engines, or Sage's built-in LDA model)<br>
          </figcaption>

          <p>All of the engines performed within 2% with regards to correct PSM identifications for both the synthetic
            and <i>in vivo</i> spectral libraries</p>
        </section>
      -->
        <section class="section">
          <h2><a id="chimera"></a>Chimeric spectra with Sage</h2>
          I was able to add in matching of chimeric spectra to Sage in ~55 lines of code (a nice benefit to writing your
          own search engine!). The algorithm is straight forward: after finding the best candidate for a spectrum,
          remove peaks assigned to that candidate, and search it again!
          <br>This works quite well in practice - I've observed around a 10% increase in PSMs at the cost of a 50-90%
          increase in total run time. Here are some nice examples of
          spectra that can have multiple candidate peptides assigned (from the first file of the TMT benchmark data set)

          <img src="chimera_25457.png">
          <!-- <img src="chimera_27525.png"> -->
          <img src="chimera_29213.png">
          <!-- <img src="chimera_31327.png"> -->
          <img src="chimera_34766.png">


          We can run the chimeric search on our non-TMT labeled dataset as well (<a
            href="http://proteomecentral.proteomexchange.org/cgi/GetDataset?ID=PXD001468">PXD001468</a>), and we
          identify some ~1,800 scans with chimeric spectra (1% FDR as scored by Sage).
          <img src="chimera_b49707.png">
          <figcaption>Example of a chimeric spectra from PXD001468</figcaption>

          Running these chimeric spectra through the <a href="https://iomics.ugent.be/deeplc/">DeepLC</a> retention time
          predictor shows that many of these spectra also make sense from a co-elution perspective.
          <img src="chimera_rt.png">
        </section>
        <section class="section">
          <h2><a id="lda"></a>Linear Discriminant Analysis</h2>
          Most database search algorithms compute multiple scores for a given peptide-spectrum match (e.g. XCorr, Delta
          CN).
          In the olden days (especially before target-decoy competition), mass spectrometrists would apply separate
          thresholds to each score to refine the false discovery rate - the majority of search engines do not directly
          calculate the FDR.
          <p>
            Several post-searching approaches (Percolator, PeptideProphet, etc) have been described that utilize machine
            learning or expectation-maximization algorithms to
            combine multiple features in order to better refine the FDR - this yields more PSMs for final analysis when
            compared to simple filtering off of just 1 score feature (XCorr/etc).
          </p>
          <p>
            In my opinion, the most explanable approach is "linear discriminant analysis" - this technique returns a
            linear combination of features that can be reduced to a single "discriminant score" that maximizes the
            distance between our target and decoy PSMs.
          </p>
          For instance, here are a subset of the features Sage calculates for each candidate peptide-spectrum match:
          <table>
            <thead>
              <th>Feature</th>
              <th>Description</th>
            </thead>
            <tbody>
              <tr>
                <td>Hyperscore</td>
                <td>Primary score function</td>
              </tr>
              <tr>
                <td>Delta hyperscore</td>
                <td>Δ between current candidate and next best candidate</td>
              </tr>
              <tr>
                <td>Delta mass</td>
                <td>Difference between experimental & calculated precursor mass</td>
              </tr>
              <tr>
                <td>Average ppm</td>
                <td>Average difference between experiment & calculated fragment masses</td>
              </tr>
              <tr>
                <td>Longest y</td>
                <td># of y-ions in the longest continous ion ladder</td>
              </tr>
              <tr>
                <td>Poisson</td>
                <td>Log probability of matching exactly N fragment peaks</td>
              </tr>
            </tbody>
          </table>

          <p>
            These features can all be combined to find a combination that performs better than filtering off of one
            alone.
          </p>
          <img src="SageLDA.png">
          <figcaption>Sage LDA typically performs well within 1% of Percolator/Mokapot</figcaption>

          <p>
            I got tired of having to post-process my results, so I implemented Linear Discriminant Analysis directly in
            Sage (see graph above) - this allows us to find the coefficient for each feature that provides the best
            separation between our known-decoys and targets.
            Unfortunately, Rust doesn't have a strong selection of ML libraries, so I had to built it out completely
            from scratch - starting with a linear algebra module. As a side benefit, I now understand what a eigenvector
            is!
          </p>
          <p>
            In the end, I built a hand-rolled LDA algorithm that achieves 1:1 results with the popular Python
            scikit-learn package, but is 25-50% faster. I also implemented a non-parametric model (kernel density
            estimation) for calculation of the "posterior error probability" (local FDR - the probability that a given
            PSM is incorrect) for each PSM.
            For a full discussion on false discovery rates and posterior error probabilities, I highly recommend the
            excellent paper
            <a href="https://noble.gs.washington.edu/papers/kall2008posterior.pdf">Käll et al., 2008</a>.
          </p>
          <img src="PEP.png" class="large">
          <figcaption>Sage accurately & rapidly computes FDR and PEP</figcaption>
        </section>
        <section class="section">
          <h2><a id="tmt"></a>MS3-TMT Quantification</h2>
          This post is already getting crazy long, so I will just quickly note that Sage is capable of quantifying
          MS3-TMT reporter ions while searching!

          <p>
            It also has some fun features, like calculation of "SPS purity" - what percentage of total MS2 ion intensity
            selected for MS3 came from matched b-/y- ions?
          </p>

          <img src="hypro.png">
          <figcaption>Quantification of yeast peptides from HYpro16 TMT interference dataset</figcaption>

          <p>
            Making my own TMT quantification engine allowed me to do some investigation into ProteomeDiscoverer's
            signal-to-noise TMT measurement... and as best as I can tell, it is the reporter ion counts multiple by MS3
            ion injection time, and then divided by some constant factor (R<sup>2</sup> = 0.998).
          </p>

          <img src="pd_sn.png">
          <figcaption>Background contour is based off of linear regression, scatter plots are (X, Y) TMT measurements
            conducted by Sage, and colored by their ProteomeDiscoverer reported S/N. Internal data</figcaption>

        </section>
        <section class="section">
          <h1>Conclusions</h1>
          <p>Writing a (relatively bare-bones) proteomics search engine has been a fantastic learning experience.
            Rust has been my daily-driver programming language of choice for 5 years now, and it really makes writing
            performant software a breeze, especially with fantastic packages like Rayon! If you haven't given it a try,
            I highly recommend it.
          </p>
          <p>To wrap things up, I will concede that MSFragger is indeed "ultrafast", and has better PSM
            identification at the widest open windows - unless you turn on chimeric search!
            Until then, I recommend continuing to use MSFragger if you're doing wide-open searches.<sup
              class="footnote-ref"></sup>
          <aside class="footnote">
            I did not originally intend to develop a production-ready tool, but I think with some additional work, Sage
            could get there
          </aside>
          </p>
          <p>If you would like to try out Sage yourself, you only need to do a couple steps:</p>
          <p>First, head on over to <a href="https://rustup.rs/">rustup.rs</a> and install Rust/Cargo</p>
          <p>
            Then, run the following commands:<br>
          <div class="codeblock">
            <code>
              git clone https://github.com/lazear/sage.git<br>
              cd sage<br>
              cargo run --release tmt.json
            </code>
          </div>
          </p>
          Example tmt.json file:
          <script src="https://gist.github.com/lazear/8dc144fb57a74ec32bc72e1f03d96950.js"></script>

          <h3>Acknowledges</h3>
          I'd like to thank Phil Wilmarth, Jimmy Eng, and Alexey Nesvizhskii for providing feedback on search params
        </section>
        <section class="section" id="footnote-section">
          <h3>Footnotes</h3>

        </section>
      </article>
      <!-- </div> -->
      <footer class="footer">
        <p>Copyright Michael Lazear, 2022. Website content is licensed <a
            href="http://creativecommons.org/licenses/by/4.0/">CC BY
            4.0</a>.
        </p>
      </footer>
    </div>
  </main>
  <script src="engine.js"></script>
</body>

</html>